{"ast":null,"code":"export const FileService = {\n  stringToTextFile(content, fileName) {\n    try {\n      const blob = new Blob([content], {\n        type: 'text/plain'\n      });\n      return new File([blob], `${fileName}.txt`, {\n        type: 'text/plain'\n      });\n    } catch (error) {\n      throw new Error('Failed to convert string to text file: ' + error.message);\n    }\n  },\n  textFileToString(file) {\n    return new Promise((resolve, reject) => {\n      if (file.type !== 'text/plain') {\n        reject(new Error('File must be a text file'));\n        return;\n      }\n      const reader = new FileReader();\n      reader.onload = () => {\n        if (typeof reader.result === 'string') {\n          resolve(reader.result);\n        } else {\n          reject(new Error('Failed to read text file'));\n        }\n      };\n      reader.onerror = error => {\n        reject(new Error('Error reading text file: ' + error));\n      };\n      reader.readAsText(file);\n    });\n  },\n  imageToString(imageFile) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        if (typeof reader.result === 'string') {\n          resolve(reader.result);\n        } else {\n          reject(new Error('Failed to convert image to string'));\n        }\n      };\n      reader.onerror = error => {\n        reject(new Error('Error reading image file: ' + error));\n      };\n      reader.readAsDataURL(imageFile);\n    });\n  },\n  stringToImage(base64String, fileName = 'image') {\n    try {\n      const matches = base64String.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n      if (!matches || matches.length !== 3) {\n        throw new Error('Invalid base64 string format');\n      }\n      const mimeType = matches[1];\n      const base64Data = matches[2];\n      const byteCharacters = atob(base64Data);\n      const byteArrays = [];\n      for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n        const slice = byteCharacters.slice(offset, offset + 512);\n        const byteNumbers = new Array(slice.length);\n        for (let i = 0; i < slice.length; i++) {\n          byteNumbers[i] = slice.charCodeAt(i);\n        }\n        byteArrays.push(new Uint8Array(byteNumbers));\n      }\n      const blob = new Blob(byteArrays, {\n        type: mimeType\n      });\n      const extension = mimeType.split('/')[1] || 'jpg';\n      return new File([blob], `${fileName}.${extension}`, {\n        type: mimeType\n      });\n    } catch (error) {\n      throw new Error('Failed to convert string to image: ' + error.message);\n    }\n  },\n  // New universal file conversion functions\n  fileToString(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        if (typeof reader.result === 'string') {\n          resolve({\n            content: reader.result,\n            fileType: file.type\n          });\n        } else {\n          reject(new Error('Failed to convert file to string'));\n        }\n      };\n      reader.onerror = error => {\n        reject(new Error('Error reading file: ' + error));\n      };\n      if (file.type === 'text/plain') {\n        reader.readAsText(file);\n      } else {\n        reader.readAsDataURL(file);\n      }\n    });\n  },\n  stringToFile(fileString, fileName, fileType) {\n    try {\n      // Handle text files\n      if (fileType === 'text/plain') {\n        const blob = new Blob([fileString], {\n          type: fileType\n        });\n        return new File([blob], fileName, {\n          type: fileType\n        });\n      }\n\n      // Handle base64 data URLs for other file types\n      if (fileString.startsWith('data:')) {\n        const matches = fileString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n        if (!matches || matches.length !== 3) {\n          throw new Error('Invalid base64 string format');\n        }\n        const actualFileType = matches[1];\n        const base64Data = matches[2];\n        const byteCharacters = atob(base64Data);\n        const byteArrays = [];\n        for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n          const slice = byteCharacters.slice(offset, offset + 512);\n          const byteNumbers = new Array(slice.length);\n          for (let i = 0; i < slice.length; i++) {\n            byteNumbers[i] = slice.charCodeAt(i);\n          }\n          byteArrays.push(new Uint8Array(byteNumbers));\n        }\n        const blob = new Blob(byteArrays, {\n          type: actualFileType\n        });\n        return new File([blob], fileName, {\n          type: actualFileType\n        });\n      }\n      throw new Error('Unsupported string format');\n    } catch (error) {\n      throw new Error('Failed to convert string to file: ' + error.message);\n    }\n  }\n};\nexport default FileService;","map":{"version":3,"names":["FileService","stringToTextFile","content","fileName","blob","Blob","type","File","error","Error","message","textFileToString","file","Promise","resolve","reject","reader","FileReader","onload","result","onerror","readAsText","imageToString","imageFile","readAsDataURL","stringToImage","base64String","matches","match","length","mimeType","base64Data","byteCharacters","atob","byteArrays","offset","slice","byteNumbers","Array","i","charCodeAt","push","Uint8Array","extension","split","fileToString","fileType","stringToFile","fileString","startsWith","actualFileType"],"sources":["/home/n/Desktop/privchat10.11.2024/privchatFrontend/src/api/FileService.ts"],"sourcesContent":["export const FileService = {\n    stringToTextFile(content: BlobPart, fileName: string) {\n      try {\n        const blob = new Blob([content], { type: 'text/plain' });\n        return new File([blob], `${fileName}.txt`, { type: 'text/plain' });\n      } catch (error: any) {\n        throw new Error('Failed to convert string to text file: ' + error.message);\n      }\n    },\n  \n    textFileToString(file: Blob):Promise<string> {\n      return new Promise((resolve, reject) => {\n        if (file.type !== 'text/plain') {\n          reject(new Error('File must be a text file'));\n          return;\n        }\n        const reader = new FileReader();\n        reader.onload = () => {\n          if (typeof reader.result === 'string') {\n            resolve(reader.result);\n          } else {\n            reject(new Error('Failed to read text file'));\n          }\n        };\n        reader.onerror = (error) => {\n          reject(new Error('Error reading text file: ' + error));\n        };\n        reader.readAsText(file);\n      });\n    },\n  \n    imageToString(imageFile: Blob): Promise<string> {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        reader.onload = () => {\n          if (typeof reader.result === 'string') {\n            resolve(reader.result);\n          } else {\n            reject(new Error('Failed to convert image to string'));\n          }\n        };\n        reader.onerror = (error) => {\n          reject(new Error('Error reading image file: ' + error));\n        };\n        reader.readAsDataURL(imageFile);\n      });\n    },\n  \n    stringToImage(base64String: string, fileName = 'image') {\n      try {\n        const matches = base64String.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n        if (!matches || matches.length !== 3) {\n          throw new Error('Invalid base64 string format');\n        }\n        const mimeType = matches[1];\n        const base64Data = matches[2];\n        const byteCharacters = atob(base64Data);\n        const byteArrays = [];\n        for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n          const slice = byteCharacters.slice(offset, offset + 512);\n          const byteNumbers = new Array(slice.length);\n          for (let i = 0; i < slice.length; i++) {\n            byteNumbers[i] = slice.charCodeAt(i);\n          }\n          byteArrays.push(new Uint8Array(byteNumbers));\n        }\n        const blob = new Blob(byteArrays, { type: mimeType });\n        const extension = mimeType.split('/')[1] || 'jpg';\n        return new File([blob], `${fileName}.${extension}`, { type: mimeType });\n      } catch (error: any) {\n        throw new Error('Failed to convert string to image: ' + error.message);\n      }\n    },\n  \n    // New universal file conversion functions\n    fileToString(file: File): Promise<{ content: string; fileType: string }> {\n      return new Promise((resolve, reject) => {\n        const reader = new FileReader();\n        \n        reader.onload = () => {\n          if (typeof reader.result === 'string') {\n            resolve({\n              content: reader.result,\n              fileType: file.type\n            });\n          } else {\n            reject(new Error('Failed to convert file to string'));\n          }\n        };\n        \n        reader.onerror = (error) => {\n          reject(new Error('Error reading file: ' + error));\n        };\n        \n        if (file.type === 'text/plain') {\n          reader.readAsText(file);\n        } else {\n          reader.readAsDataURL(file);\n        }\n      });\n    },\n  \n    stringToFile(fileString: string, fileName: string, fileType: string): File {\n      try {\n        // Handle text files\n        if (fileType === 'text/plain') {\n          const blob = new Blob([fileString], { type: fileType });\n          return new File([blob], fileName, { type: fileType });\n        }\n        \n        // Handle base64 data URLs for other file types\n        if (fileString.startsWith('data:')) {\n          const matches = fileString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          \n          if (!matches || matches.length !== 3) {\n            throw new Error('Invalid base64 string format');\n          }\n  \n          const actualFileType = matches[1];\n          const base64Data = matches[2];\n          \n          const byteCharacters = atob(base64Data);\n          const byteArrays = [];\n  \n          for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n            const slice = byteCharacters.slice(offset, offset + 512);\n            const byteNumbers = new Array(slice.length);\n            \n            for (let i = 0; i < slice.length; i++) {\n              byteNumbers[i] = slice.charCodeAt(i);\n            }\n            \n            byteArrays.push(new Uint8Array(byteNumbers));\n          }\n  \n          const blob = new Blob(byteArrays, { type: actualFileType });\n          return new File([blob], fileName, { type: actualFileType });\n        }\n        \n        throw new Error('Unsupported string format');\n      } catch (error: any) {\n        throw new Error('Failed to convert string to file: ' + error.message);\n      }\n    }\n  };\n  \n  export default FileService;"],"mappings":"AAAA,OAAO,MAAMA,WAAW,GAAG;EACvBC,gBAAgBA,CAACC,OAAiB,EAAEC,QAAgB,EAAE;IACpD,IAAI;MACF,MAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC,CAACH,OAAO,CAAC,EAAE;QAAEI,IAAI,EAAE;MAAa,CAAC,CAAC;MACxD,OAAO,IAAIC,IAAI,CAAC,CAACH,IAAI,CAAC,EAAE,GAAGD,QAAQ,MAAM,EAAE;QAAEG,IAAI,EAAE;MAAa,CAAC,CAAC;IACpE,CAAC,CAAC,OAAOE,KAAU,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,yCAAyC,GAAGD,KAAK,CAACE,OAAO,CAAC;IAC5E;EACF,CAAC;EAEDC,gBAAgBA,CAACC,IAAU,EAAkB;IAC3C,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,IAAIH,IAAI,CAACN,IAAI,KAAK,YAAY,EAAE;QAC9BS,MAAM,CAAC,IAAIN,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC7C;MACF;MACA,MAAMO,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAC/BD,MAAM,CAACE,MAAM,GAAG,MAAM;QACpB,IAAI,OAAOF,MAAM,CAACG,MAAM,KAAK,QAAQ,EAAE;UACrCL,OAAO,CAACE,MAAM,CAACG,MAAM,CAAC;QACxB,CAAC,MAAM;UACLJ,MAAM,CAAC,IAAIN,KAAK,CAAC,0BAA0B,CAAC,CAAC;QAC/C;MACF,CAAC;MACDO,MAAM,CAACI,OAAO,GAAIZ,KAAK,IAAK;QAC1BO,MAAM,CAAC,IAAIN,KAAK,CAAC,2BAA2B,GAAGD,KAAK,CAAC,CAAC;MACxD,CAAC;MACDQ,MAAM,CAACK,UAAU,CAACT,IAAI,CAAC;IACzB,CAAC,CAAC;EACJ,CAAC;EAEDU,aAAaA,CAACC,SAAe,EAAmB;IAC9C,OAAO,IAAIV,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAC/BD,MAAM,CAACE,MAAM,GAAG,MAAM;QACpB,IAAI,OAAOF,MAAM,CAACG,MAAM,KAAK,QAAQ,EAAE;UACrCL,OAAO,CAACE,MAAM,CAACG,MAAM,CAAC;QACxB,CAAC,MAAM;UACLJ,MAAM,CAAC,IAAIN,KAAK,CAAC,mCAAmC,CAAC,CAAC;QACxD;MACF,CAAC;MACDO,MAAM,CAACI,OAAO,GAAIZ,KAAK,IAAK;QAC1BO,MAAM,CAAC,IAAIN,KAAK,CAAC,4BAA4B,GAAGD,KAAK,CAAC,CAAC;MACzD,CAAC;MACDQ,MAAM,CAACQ,aAAa,CAACD,SAAS,CAAC;IACjC,CAAC,CAAC;EACJ,CAAC;EAEDE,aAAaA,CAACC,YAAoB,EAAEvB,QAAQ,GAAG,OAAO,EAAE;IACtD,IAAI;MACF,MAAMwB,OAAO,GAAGD,YAAY,CAACE,KAAK,CAAC,mCAAmC,CAAC;MACvE,IAAI,CAACD,OAAO,IAAIA,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE;QACpC,MAAM,IAAIpB,KAAK,CAAC,8BAA8B,CAAC;MACjD;MACA,MAAMqB,QAAQ,GAAGH,OAAO,CAAC,CAAC,CAAC;MAC3B,MAAMI,UAAU,GAAGJ,OAAO,CAAC,CAAC,CAAC;MAC7B,MAAMK,cAAc,GAAGC,IAAI,CAACF,UAAU,CAAC;MACvC,MAAMG,UAAU,GAAG,EAAE;MACrB,KAAK,IAAIC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,cAAc,CAACH,MAAM,EAAEM,MAAM,IAAI,GAAG,EAAE;QAClE,MAAMC,KAAK,GAAGJ,cAAc,CAACI,KAAK,CAACD,MAAM,EAAEA,MAAM,GAAG,GAAG,CAAC;QACxD,MAAME,WAAW,GAAG,IAAIC,KAAK,CAACF,KAAK,CAACP,MAAM,CAAC;QAC3C,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACP,MAAM,EAAEU,CAAC,EAAE,EAAE;UACrCF,WAAW,CAACE,CAAC,CAAC,GAAGH,KAAK,CAACI,UAAU,CAACD,CAAC,CAAC;QACtC;QACAL,UAAU,CAACO,IAAI,CAAC,IAAIC,UAAU,CAACL,WAAW,CAAC,CAAC;MAC9C;MACA,MAAMjC,IAAI,GAAG,IAAIC,IAAI,CAAC6B,UAAU,EAAE;QAAE5B,IAAI,EAAEwB;MAAS,CAAC,CAAC;MACrD,MAAMa,SAAS,GAAGb,QAAQ,CAACc,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,KAAK;MACjD,OAAO,IAAIrC,IAAI,CAAC,CAACH,IAAI,CAAC,EAAE,GAAGD,QAAQ,IAAIwC,SAAS,EAAE,EAAE;QAAErC,IAAI,EAAEwB;MAAS,CAAC,CAAC;IACzE,CAAC,CAAC,OAAOtB,KAAU,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,qCAAqC,GAAGD,KAAK,CAACE,OAAO,CAAC;IACxE;EACF,CAAC;EAED;EACAmC,YAAYA,CAACjC,IAAU,EAAkD;IACvE,OAAO,IAAIC,OAAO,CAAC,CAACC,OAAO,EAAEC,MAAM,KAAK;MACtC,MAAMC,MAAM,GAAG,IAAIC,UAAU,CAAC,CAAC;MAE/BD,MAAM,CAACE,MAAM,GAAG,MAAM;QACpB,IAAI,OAAOF,MAAM,CAACG,MAAM,KAAK,QAAQ,EAAE;UACrCL,OAAO,CAAC;YACNZ,OAAO,EAAEc,MAAM,CAACG,MAAM;YACtB2B,QAAQ,EAAElC,IAAI,CAACN;UACjB,CAAC,CAAC;QACJ,CAAC,MAAM;UACLS,MAAM,CAAC,IAAIN,KAAK,CAAC,kCAAkC,CAAC,CAAC;QACvD;MACF,CAAC;MAEDO,MAAM,CAACI,OAAO,GAAIZ,KAAK,IAAK;QAC1BO,MAAM,CAAC,IAAIN,KAAK,CAAC,sBAAsB,GAAGD,KAAK,CAAC,CAAC;MACnD,CAAC;MAED,IAAII,IAAI,CAACN,IAAI,KAAK,YAAY,EAAE;QAC9BU,MAAM,CAACK,UAAU,CAACT,IAAI,CAAC;MACzB,CAAC,MAAM;QACLI,MAAM,CAACQ,aAAa,CAACZ,IAAI,CAAC;MAC5B;IACF,CAAC,CAAC;EACJ,CAAC;EAEDmC,YAAYA,CAACC,UAAkB,EAAE7C,QAAgB,EAAE2C,QAAgB,EAAQ;IACzE,IAAI;MACF;MACA,IAAIA,QAAQ,KAAK,YAAY,EAAE;QAC7B,MAAM1C,IAAI,GAAG,IAAIC,IAAI,CAAC,CAAC2C,UAAU,CAAC,EAAE;UAAE1C,IAAI,EAAEwC;QAAS,CAAC,CAAC;QACvD,OAAO,IAAIvC,IAAI,CAAC,CAACH,IAAI,CAAC,EAAED,QAAQ,EAAE;UAAEG,IAAI,EAAEwC;QAAS,CAAC,CAAC;MACvD;;MAEA;MACA,IAAIE,UAAU,CAACC,UAAU,CAAC,OAAO,CAAC,EAAE;QAClC,MAAMtB,OAAO,GAAGqB,UAAU,CAACpB,KAAK,CAAC,mCAAmC,CAAC;QAErE,IAAI,CAACD,OAAO,IAAIA,OAAO,CAACE,MAAM,KAAK,CAAC,EAAE;UACpC,MAAM,IAAIpB,KAAK,CAAC,8BAA8B,CAAC;QACjD;QAEA,MAAMyC,cAAc,GAAGvB,OAAO,CAAC,CAAC,CAAC;QACjC,MAAMI,UAAU,GAAGJ,OAAO,CAAC,CAAC,CAAC;QAE7B,MAAMK,cAAc,GAAGC,IAAI,CAACF,UAAU,CAAC;QACvC,MAAMG,UAAU,GAAG,EAAE;QAErB,KAAK,IAAIC,MAAM,GAAG,CAAC,EAAEA,MAAM,GAAGH,cAAc,CAACH,MAAM,EAAEM,MAAM,IAAI,GAAG,EAAE;UAClE,MAAMC,KAAK,GAAGJ,cAAc,CAACI,KAAK,CAACD,MAAM,EAAEA,MAAM,GAAG,GAAG,CAAC;UACxD,MAAME,WAAW,GAAG,IAAIC,KAAK,CAACF,KAAK,CAACP,MAAM,CAAC;UAE3C,KAAK,IAAIU,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGH,KAAK,CAACP,MAAM,EAAEU,CAAC,EAAE,EAAE;YACrCF,WAAW,CAACE,CAAC,CAAC,GAAGH,KAAK,CAACI,UAAU,CAACD,CAAC,CAAC;UACtC;UAEAL,UAAU,CAACO,IAAI,CAAC,IAAIC,UAAU,CAACL,WAAW,CAAC,CAAC;QAC9C;QAEA,MAAMjC,IAAI,GAAG,IAAIC,IAAI,CAAC6B,UAAU,EAAE;UAAE5B,IAAI,EAAE4C;QAAe,CAAC,CAAC;QAC3D,OAAO,IAAI3C,IAAI,CAAC,CAACH,IAAI,CAAC,EAAED,QAAQ,EAAE;UAAEG,IAAI,EAAE4C;QAAe,CAAC,CAAC;MAC7D;MAEA,MAAM,IAAIzC,KAAK,CAAC,2BAA2B,CAAC;IAC9C,CAAC,CAAC,OAAOD,KAAU,EAAE;MACnB,MAAM,IAAIC,KAAK,CAAC,oCAAoC,GAAGD,KAAK,CAACE,OAAO,CAAC;IACvE;EACF;AACF,CAAC;AAED,eAAeV,WAAW","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}