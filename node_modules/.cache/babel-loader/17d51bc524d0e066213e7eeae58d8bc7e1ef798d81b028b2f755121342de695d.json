{"ast":null,"code":"import * as CryptoJS from 'crypto-js';\nconst P = BigInt(23);\nconst g = BigInt(2);\nexport const DiffieHellmanService = {\n  generateSecret() {\n    const randomKey = BigInt(Math.floor(Math.random() * Number(P - g) + 1));\n    return randomKey;\n  },\n  modularExponentiation(base, exponent, modulus) {\n    if (modulus === BigInt(1)) return BigInt(0);\n    let result = BigInt(1);\n    base = base % modulus;\n    while (exponent > 0) {\n      if (exponent % BigInt(2) === BigInt(1)) {\n        result = result * base % modulus;\n      }\n      exponent = exponent >> BigInt(1);\n      base = base * base % modulus;\n    }\n    return result;\n  },\n  generatePublicKey(secret) {\n    const pubKey = this.modularExponentiation(g, secret, P);\n    return pubKey;\n  },\n  generateSharedSecret(otherPartyPublicKey, ownPrivateKey) {\n    if (!otherPartyPublicKey || !ownPrivateKey) return null;\n    return this.modularExponentiation(BigInt(otherPartyPublicKey), BigInt(ownPrivateKey), P);\n  },\n  handleGenerateKeys() {\n    var secret = this.generateSecret();\n    const publicKey = String(this.generatePublicKey(secret));\n    console.log(\"Private Key (Secret):\", secret.toString());\n    console.log(\"Public Key:\", publicKey.toString());\n    return {\n      secret,\n      publicKey\n    };\n  },\n  encrypt(plainText, secretKey) {\n    const cipherText = CryptoJS.AES.encrypt(plainText, secretKey).toString();\n    return cipherText;\n  },\n  decrypt(cipherText, secretKey) {\n    const bytes = CryptoJS.AES.decrypt(cipherText, secretKey);\n    const plainText = bytes.toString(CryptoJS.enc.Utf8);\n    return plainText;\n  },\n  decryptMessages(messages, secretKey) {\n    const decryptedMessages = messages.map(msg => {\n      if (!msg.content) return {};\n      msg.content = this.decrypt(msg.content, secretKey);\n      return msg;\n    });\n    return decryptedMessages;\n  },\n  async encryptFile(file, secretKey) {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n      reader.onload = () => {\n        try {\n          const fileData = reader.result;\n          const encryptedData = this.encrypt(fileData, secretKey);\n          const encryptedBlob = new Blob([encryptedData], {\n            type: file.type\n          });\n          const encryptedFile = new File([encryptedBlob], `${file.name}.enc`, {\n            type: file.type\n          });\n          resolve(encryptedFile);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      reader.onerror = error => reject(error);\n      reader.readAsText(file);\n    });\n  },\n  async decryptFile(encryptedFile, secretKey) {\n    const reader = new FileReader();\n    return new Promise((resolve, reject) => {\n      reader.onload = () => {\n        try {\n          const encryptedData = reader.result;\n          const decryptedData = this.decrypt(encryptedData, secretKey);\n\n          // Remove timestamp from the file name\n          const removeTimestamp = filename => filename.replace(/^\\d+_/, '');\n          const newFileName = removeTimestamp(encryptedFile.name.replace('.enc', ''));\n          const decryptedBlob = new Blob([decryptedData], {\n            type: encryptedFile.type\n          });\n          const decryptedFile = new File([decryptedBlob], newFileName, {\n            type: encryptedFile.type\n          });\n          resolve(decryptedFile);\n        } catch (error) {\n          reject(error);\n        }\n      };\n      reader.onerror = error => reject(error);\n      reader.readAsText(encryptedFile);\n    });\n  },\n  // async encryptImage(file: File, secretKey: string): Promise<string> {\n  //   try {\n  //     // Convert File to base64 string\n  //     const base64String = await new Promise<string>((resolve, reject) => {\n  //       const reader = new FileReader();\n  //       reader.onload = () => {\n  //         if (typeof reader.result === 'string') {\n  //           resolve(reader.result);\n  //         } else {\n  //           reject(new Error('Failed to read file'));\n  //         }\n  //       };\n  //       reader.onerror = reject;\n  //       reader.readAsDataURL(file);\n  //     });\n\n  //     // Encrypt the base64 string\n  //     const encrypted = CryptoJS.AES.encrypt(base64String, secretKey).toString();\n  //     return encrypted;\n  //   } catch (error) {\n  //     console.error('Error encrypting image:', error);\n  //     throw new Error('Failed to encrypt image');\n  //   }\n  // },\n  // decryptImage(encryptedString: string, secretKey: string, fileName: string = 'decrypted-image'): File {\n  //   try {\n  //     // Decrypt the string\n  //     const decrypted = CryptoJS.AES.decrypt(encryptedString, secretKey);\n  //     const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\n\n  //     // Extract the mime type and base64 data\n  //     const matches = decryptedString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n\n  //     if (!matches || matches.length !== 3) {\n  //       throw new Error('Invalid decrypted data format');\n  //     }\n\n  //     const mimeType = matches[1];\n  //     const base64Data = matches[2];\n\n  //     // Convert base64 to blob\n  //     const byteCharacters = atob(base64Data);\n  //     const byteArrays = [];\n\n  //     for (let offset = 0; offset < byteCharacters.length; offset += 1024) {\n  //       const slice = byteCharacters.slice(offset, offset + 1024);\n  //       const byteNumbers = new Array(slice.length);\n\n  //       for (let i = 0; i < slice.length; i++) {\n  //         byteNumbers[i] = slice.charCodeAt(i);\n  //       }\n\n  //       byteArrays.push(new Uint8Array(byteNumbers));\n  //     }\n\n  //     // Create File object\n  //     const blob = new Blob(byteArrays, { type: mimeType });\n  //     const extension = mimeType.split('/')[1] || 'jpg';\n  //     return new File([blob], `${fileName}.${extension}`, { type: mimeType });\n  //   } catch (error) {\n  //     console.error('Error decrypting image:', error);\n  //     throw new Error('Failed to decrypt image');\n  //   }\n  // },\n  imageToString(imageFile) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        if (typeof reader.result === 'string') {\n          resolve(reader.result);\n        } else {\n          reject(new Error('Failed to convert image to string'));\n        }\n      };\n      reader.onerror = error => {\n        reject(new Error('Error reading image file: ' + error));\n      };\n      reader.readAsDataURL(imageFile);\n    });\n  },\n  stringToImage(base64String, fileName = 'image') {\n    try {\n      // Extract the mime type and base64 data\n      const matches = base64String.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n      if (!matches || matches.length !== 3) {\n        throw new Error('Invalid base64 string format');\n      }\n      const mimeType = matches[1];\n      const base64Data = matches[2];\n\n      // Convert base64 to binary\n      const byteCharacters = atob(base64Data);\n      const byteArrays = [];\n\n      // Process data in chunks to handle large files\n      for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n        const slice = byteCharacters.slice(offset, offset + 512);\n        const byteNumbers = new Array(slice.length);\n        for (let i = 0; i < slice.length; i++) {\n          byteNumbers[i] = slice.charCodeAt(i);\n        }\n        byteArrays.push(new Uint8Array(byteNumbers));\n      }\n\n      // Create the File object\n      const blob = new Blob(byteArrays, {\n        type: mimeType\n      });\n      const extension = mimeType.split('/')[1] || 'jpg';\n      return new File([blob], `${fileName}.${extension}`, {\n        type: mimeType\n      });\n    } catch (error) {\n      throw new Error('Failed to convert string to image: ' + error.message);\n    }\n  },\n  fileToBase64(file) {\n    return new Promise((resolve, reject) => {\n      const reader = new FileReader();\n      reader.readAsDataURL(file);\n      reader.onload = () => resolve(reader.result);\n      reader.onerror = error => reject(error);\n    });\n  }\n};\nexport default DiffieHellmanService;","map":{"version":3,"names":["CryptoJS","P","BigInt","g","DiffieHellmanService","generateSecret","randomKey","Math","floor","random","Number","modularExponentiation","base","exponent","modulus","result","generatePublicKey","secret","pubKey","generateSharedSecret","otherPartyPublicKey","ownPrivateKey","handleGenerateKeys","publicKey","String","console","log","toString","encrypt","plainText","secretKey","cipherText","AES","decrypt","bytes","enc","Utf8","decryptMessages","messages","decryptedMessages","map","msg","content","encryptFile","file","reader","FileReader","Promise","resolve","reject","onload","fileData","encryptedData","encryptedBlob","Blob","type","encryptedFile","File","name","error","onerror","readAsText","decryptFile","decryptedData","removeTimestamp","filename","replace","newFileName","decryptedBlob","decryptedFile","imageToString","imageFile","Error","readAsDataURL","stringToImage","base64String","fileName","matches","match","length","mimeType","base64Data","byteCharacters","atob","byteArrays","offset","slice","byteNumbers","Array","i","charCodeAt","push","Uint8Array","blob","extension","split","message","fileToBase64"],"sources":["/home/n/Desktop/privchat10.11.2024/privchatFrontend/src/api/DiffieHellmanService.ts"],"sourcesContent":["import * as CryptoJS from 'crypto-js';\nimport { MessageInterface } from '../types';\n\n\nconst P = BigInt(23)\nconst g = BigInt(2)\n\n\n\nexport const DiffieHellmanService = {\n    generateSecret() {\n        const randomKey = BigInt(Math.floor(Math.random() * Number(P - g) + 1));\n        return randomKey;\n    },\n\n    modularExponentiation(base: bigint, exponent: bigint, modulus: bigint) {\n        if (modulus === BigInt(1)) return BigInt(0);\n        let result = BigInt(1);\n        base = base % modulus;\n        while (exponent > 0) {\n            if (exponent % BigInt(2) === BigInt(1)) {\n                result = (result * base) % modulus;\n            }\n            exponent = exponent >> BigInt(1);\n            base = (base * base) % modulus;\n        }\n        return result;\n    },\n\n    generatePublicKey(secret: bigint) {\n        const pubKey = this.modularExponentiation(g, secret, P);\n        return pubKey;\n    },\n\n    generateSharedSecret(otherPartyPublicKey: string, ownPrivateKey: string) {\n        if (!otherPartyPublicKey || !ownPrivateKey) return null;\n        return this.modularExponentiation(BigInt(otherPartyPublicKey), BigInt(ownPrivateKey), P);\n    },\n\n    handleGenerateKeys() {\n        var secret = this.generateSecret();\n        const publicKey = String(this.generatePublicKey(secret));\n        console.log(\"Private Key (Secret):\", secret.toString());\n        console.log(\"Public Key:\", publicKey.toString());\n        return { secret, publicKey };\n    },\n\n    encrypt(plainText: string, secretKey: string) {\n        const cipherText = CryptoJS.AES.encrypt(plainText, secretKey).toString()\n        return cipherText\n    },\n\n    decrypt(cipherText: string, secretKey: string) {\n        const bytes = CryptoJS.AES.decrypt(cipherText, secretKey)\n        const plainText = bytes.toString(CryptoJS.enc.Utf8)\n        return plainText\n    },\n\n    decryptMessages(messages: MessageInterface[], secretKey: string) {\n      \n        const decryptedMessages = messages.map((msg) => {\n          if (!msg.content) return {}\n          \n            msg.content = this.decrypt(msg.content, secretKey)\n            return msg\n        })\n\n        return decryptedMessages\n    },\n\n    async encryptFile(file: File, secretKey: string): Promise<File> {\n        const reader = new FileReader();\n        return new Promise((resolve, reject) => {\n          reader.onload = () => {\n            try {\n              const fileData = reader.result as string;\n              const encryptedData = this.encrypt(fileData, secretKey);\n    \n              const encryptedBlob = new Blob([encryptedData], { type: file.type });\n              const encryptedFile = new File([encryptedBlob], `${file.name}.enc`, {\n                type: file.type,\n              });\n    \n              resolve(encryptedFile);\n            } catch (error) {\n              reject(error);\n            }\n          };\n    \n          reader.onerror = (error) => reject(error);\n          reader.readAsText(file);\n        });\n      },\n    \n      async decryptFile(encryptedFile: File, secretKey: string): Promise<File> {\n        const reader = new FileReader();\n        return new Promise((resolve, reject) => {\n          reader.onload = () => {\n            try {\n              const encryptedData = reader.result as string;\n              const decryptedData = this.decrypt(encryptedData, secretKey);\n      \n              // Remove timestamp from the file name\n              const removeTimestamp = (filename: string) => filename.replace(/^\\d+_/, '');\n              const newFileName = removeTimestamp(encryptedFile.name.replace('.enc', ''));\n      \n              const decryptedBlob = new Blob([decryptedData], { type: encryptedFile.type });\n              const decryptedFile = new File([decryptedBlob], newFileName, {\n                type: encryptedFile.type,\n              });\n      \n              resolve(decryptedFile);\n            } catch (error) {\n              reject(error);\n            }\n          };\n      \n          reader.onerror = (error) => reject(error);\n          reader.readAsText(encryptedFile);\n        });\n      },\n      // async encryptImage(file: File, secretKey: string): Promise<string> {\n      //   try {\n      //     // Convert File to base64 string\n      //     const base64String = await new Promise<string>((resolve, reject) => {\n      //       const reader = new FileReader();\n      //       reader.onload = () => {\n      //         if (typeof reader.result === 'string') {\n      //           resolve(reader.result);\n      //         } else {\n      //           reject(new Error('Failed to read file'));\n      //         }\n      //       };\n      //       reader.onerror = reject;\n      //       reader.readAsDataURL(file);\n      //     });\n    \n      //     // Encrypt the base64 string\n      //     const encrypted = CryptoJS.AES.encrypt(base64String, secretKey).toString();\n      //     return encrypted;\n      //   } catch (error) {\n      //     console.error('Error encrypting image:', error);\n      //     throw new Error('Failed to encrypt image');\n      //   }\n      // },\n      // decryptImage(encryptedString: string, secretKey: string, fileName: string = 'decrypted-image'): File {\n      //   try {\n      //     // Decrypt the string\n      //     const decrypted = CryptoJS.AES.decrypt(encryptedString, secretKey);\n      //     const decryptedString = decrypted.toString(CryptoJS.enc.Utf8);\n    \n      //     // Extract the mime type and base64 data\n      //     const matches = decryptedString.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          \n      //     if (!matches || matches.length !== 3) {\n      //       throw new Error('Invalid decrypted data format');\n      //     }\n    \n      //     const mimeType = matches[1];\n      //     const base64Data = matches[2];\n          \n      //     // Convert base64 to blob\n      //     const byteCharacters = atob(base64Data);\n      //     const byteArrays = [];\n    \n      //     for (let offset = 0; offset < byteCharacters.length; offset += 1024) {\n      //       const slice = byteCharacters.slice(offset, offset + 1024);\n      //       const byteNumbers = new Array(slice.length);\n            \n      //       for (let i = 0; i < slice.length; i++) {\n      //         byteNumbers[i] = slice.charCodeAt(i);\n      //       }\n            \n      //       byteArrays.push(new Uint8Array(byteNumbers));\n      //     }\n    \n      //     // Create File object\n      //     const blob = new Blob(byteArrays, { type: mimeType });\n      //     const extension = mimeType.split('/')[1] || 'jpg';\n      //     return new File([blob], `${fileName}.${extension}`, { type: mimeType });\n      //   } catch (error) {\n      //     console.error('Error decrypting image:', error);\n      //     throw new Error('Failed to decrypt image');\n      //   }\n      // },\n      imageToString (imageFile: Blob) {\n        return new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          \n          reader.onload = () => {\n            if (typeof reader.result === 'string') {\n              resolve(reader.result);\n            } else {\n              reject(new Error('Failed to convert image to string'));\n            }\n          };\n          \n          reader.onerror = (error) => {\n            reject(new Error('Error reading image file: ' + error));\n          };\n          \n          reader.readAsDataURL(imageFile);\n        });\n      },\n      stringToImage (base64String: string, fileName = 'image') {\n        try {\n          // Extract the mime type and base64 data\n          const matches = base64String.match(/^data:([A-Za-z-+/]+);base64,(.+)$/);\n          \n          if (!matches || matches.length !== 3) {\n            throw new Error('Invalid base64 string format');\n          }\n      \n          const mimeType = matches[1];\n          const base64Data = matches[2];\n          \n          // Convert base64 to binary\n          const byteCharacters = atob(base64Data);\n          const byteArrays = [];\n      \n          // Process data in chunks to handle large files\n          for (let offset = 0; offset < byteCharacters.length; offset += 512) {\n            const slice = byteCharacters.slice(offset, offset + 512);\n            const byteNumbers = new Array(slice.length);\n            \n            for (let i = 0; i < slice.length; i++) {\n              byteNumbers[i] = slice.charCodeAt(i);\n            }\n            \n            byteArrays.push(new Uint8Array(byteNumbers));\n          }\n      \n          // Create the File object\n          const blob = new Blob(byteArrays, { type: mimeType });\n          const extension = mimeType.split('/')[1] || 'jpg';\n          return new File([blob], `${fileName}.${extension}`, { type: mimeType });\n        } catch (error) {\n          throw new Error('Failed to convert string to image: ' + error.message);\n        }\n      },\n\n      fileToBase64(file: File): Promise<string> {\n        return new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.readAsDataURL(file);\n          reader.onload = () => resolve(reader.result as string);\n          reader.onerror = error => reject(error);\n        });\n      }\n      \n    \n}\n\nexport default DiffieHellmanService;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}